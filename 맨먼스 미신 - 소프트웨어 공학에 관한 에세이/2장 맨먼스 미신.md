### 1. 낙관주의
> 시스템 프로그래밍 일정 관리의 바탕을 이루는 잘못된 가정
- 모든 작업이 예정된 시간 내에 완료될것 이라는 가정
  -  프로그래밍에서 사용되는 재료는 다루기 쉽고 유연하기 때문에 구현에 별다른 어어려움이 있을 거라고 생각하지는 않으며, 낙관주의는 이렇게 우리사이에 막연하게 된다.
  - 대형 프로그래밍 프로젝트는 수많은 작업으로 이뤄지며, 종종 하나가 끝나고 다음 것이 시작되는 식으로 서로 이어져 있다. 이런 각 작업이 모두 예정대로 진행될 확률이란 지극히 낮을 수 밖에 없다.

### 2. 맨먼스
> 맨먼스(man-month)란, 추정 및 일정 관리에서 투입된 노력을 셈할 때 쓰는 단위
- 프로젝트 비용은 투입된 사람 수와 달수의 곱에 따라 변하지만 작업 진척도는 그렇지 않다.

### 2.1 맨먼스가 통하지 않는 이유
<img src="https://user-images.githubusercontent.com/76692927/221560517-09410b22-4345-4b65-9a6e-8d963c31f1bc.jpeg" height="400"/>


사람과 일정이 교환 가능한 유일한 경우는, 어떤 일을 여러 사람에게 나눠줄 수 있으며 서로 간에 소통할 필요가 없는 경우(위 그림)_개발에선 불가능

<img src="https://user-images.githubusercontent.com/76692927/221561269-5d9779fd-3996-4c6e-ba56-b48f8bf66226.jpeg" height="400"/>

만약 작업의 성격상 순서가 있어서 나누기 어렵다면, 거기에 어떤 노력을 쏟아 붓더라도 일정에 아무런 영향을 미치지 못한다(위 그림)
버그를 찾고 고치는 것이 순차적으로 진행될 수밖에 없으므로 소프트웨어 개발 작업은 이처럼 분할이 어려운 경우가 많다.

<img src="https://user-images.githubusercontent.com/76692927/221561864-8615ab3b-6a4e-4a7a-b1a5-6f9f1f51bed5.jpg" height="400"/>

분할은 가능하지만 나뉜 하위 작업들을 처리하는 데 커뮤니케이션이 필요하다면, 거기에 들어가는 노력 또한 전체 작업에 포함되어야한다.
계산한 것에 못 미치는 결과를 기대할 수밖에 없다.


<img src="https://user-images.githubusercontent.com/76692927/221562284-ac60a3c5-7bee-4370-9105-dd62ff826a2e.jpg" height="400"/>

커뮤니케이션으로 추가되는 부담은 훈련과 의사소통의 두 부분으로 나뉜다
- 훈련: 모든 작업자는 기술적인 내용, 작업 목표, 전반적인 전략, 업무 계획 등에 대해 훈련을 받아야 하며 이러한 훈련은 분할할 수가 없는 작업이므로 그 부담은 추가로 투입되는 사람 수에 비례해서 증가한다.
- 의사소통: 각 파트가 모든 파트와 개별적으로 조정을 해야 한다면, 커뮤니케이션 부담은 커지게된다.
여러 사람이 모여서 회의를 통해 문제를 해결해야 한다면 작업을 나눠서 얻는 이점을 상쇄할 수도 있고 이는 위 그래프와 같다.

> 따라서 사람을 더 투입하는 것은 일정을 단축시키기는커녕 더 늘어지게 만든다.

### 3. 시스템 테스트
- 낙관주의 탓에 우리는 대개 실제 드러나는 것보다 버그 개수가 적을 거라 예상한다.

> #일정 법칙
>> 계획 수립 : 1/3
>> 
>> 코딩 : 1/6
>> 
>> 구성 요소 테스트와 초기 시스템 테스트 : 1/4
>>
>> 모든 구성 요쇼가 준비된 후의 시스템 테스트 : 1/4

> - 위 방식은 일반적인 일정 수립과 비교해서 다음과 같은 중요한 차이점이 있다
> 1. 계획 수립에 더 많은 시간이 배정되어 있다. 하지만 이렇게 해도 상세하고 탄탄한 명세를 만들어 내기엔 다소 빠듯하며, 최신 기술에 대한 연구나 조사 활동까지 포함하기에는 충분치 않다.
> 2. 전체 일정 절반을 완성된 코드의 디버깅에 할당한 것은 통상적인 경우를 많이 벗어난 것이다.
> 3. 추정하기가 쉬운 부분, 즉 코딩에는 전체 일정의 6분의 1만 배정되어 있다.

- 대부분 프로젝트에서는 일정의 절반을 테스트에 배정한 경우는 거의 없지만 그문큼의 시간을 결국 테스트에 썼다는것이다.
- 그런 프로젝트들도 상당수가 시스템 테스트 전까지는 원래 일정대로 진행은 되고 있었다.
> 초기에 일정을 수립할 때 시스템 테스트에 충분한 시간을 할애하는 것은 대단히 중요

### 4. 소심한 추정
고객의 긴급한 요청은 프로그래머가 어떤 일을 예정보다 앞당겨서 끝내도록 할 수 있지만 실제로 일이 빨리 끝나는 것은 아니다.
어떤 추정이 정략적으로 산출되지 않고 뒷받침할 데이터도 별로 없으므로 추정을 적극적으로 방어하는 것은 어렵다
그러므로 아래 두가지 해결책이 필요하다.
1. 생산성 수치, 버그 발생률, 추정 원칙 등을 공표하고 또 공유한다.
2. 추정의 기초가 더 견고해지는 그때까지 관리자들은 당당하게 스스로의 추정치를 방어해야 한다.

### 5. 일정 붕괴의 악순환

> 늦어진 소프트웨어 프로젝트에 인력을 추가로 투입하면 더 늦어지게 된다.

프로젝트에 소요되는 기간은 순서대로 처리해야 하는 내부 요소에 좌우되며, 필요한 최대 인원수는 독립된 하위 작업의 개수의 좌우된다. 따라서 더 적은 수의 사람 과 더 긴 기간 에 기초한 일정을 수립할 수 있다 (유일한 위험은 제품이 시대에 처지게 되는 것이다).

 그러나 더 많은 사람과 더 많은 사람과 더 짧은 기간으로는 실행 가능한 일정을 만들어 내지 못한다.
