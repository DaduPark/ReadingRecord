# 13장 전체 그리고 부분들
어떻게 프로그램이 제대로 동작하게할지, 어떻게 테스트 해야될지, 테스트된 일련 구성요소를 이미 테스트되고 믿을 수 있는 시스템에 통합하려면 어떻게 해야할지 그 내용을 좀더 체계적으로 검토해보자.
## 1. 버그를 줄이는 설계
### 버그를 방지하는 정의
개념적 일관성(4,5,6장에 논의)이 있는 제품은 사용하기 쉬울 뿐 아니라 만들기도 쉽고 버그가 생길 가능성도 줄어든다.  
세심한 기능 정의, 주의 깊은 명세, 겉치레 기능이나 기술적 공상을 배제하도록 훈련하는 일 모두 시스템 버그의 수를 줄여준다.
### 명세 테스트.
코드가 한 줄이라도 만들어지기 훨씬 전부터, 명세는 외부 테스팅 그룹으로 넘겨져서 완전성과 명확성을 검토받아야 한다.
### 하향식 설계.
시스템 구축을 설계, 구현, 제품화로 나눈 것은 그런 개념이 적용된 것이며 더 나아가서 설계, 구현, 제품화의 각과정은 하향식으로 이루어질 때가 가장 좋은 결과를 가져온다.  
작업 정의를 세분화함에 따라 해법을 담은 알고리즘도 점차 세분화되며, 그 과정에서 데이터 표현법 또한 세분화될 수 있다.  
이런 과정에서 해법이나 데이터 내의 '모듈'들이 드러나게 되는데, 각 모듈은 다른 작업과 무관하게 각각 세분화해 나갈 수 있다. 이런 모듈화의 정도가 프로그램의 융통성과 변경 가능성을 결정한다.  

좋은 하향식 설계는 여러 면에서 버그를 회피하도록 해준다.
1. 프로그램 구조와 데이터 표현법이 명확하므로 각 모듈의 요구 사항과 기능을 엄밀하게 기술하기 더 쉬워진다.
2. 서로 독립적인 모듈로 분할함으로써 시스템 버그가 예방된다.
3. 세부 내용을 숨김에 따라 구조상 결함이 있을 경우 눈에 더 잘 띄게 된다.
4. 각 세분화 단계마다 설계를 테스트할 수 있으므로 테스트를 더 일찍 시작할 수 있고, 단계마다 그에 맞는 수준의 세부 사항에 집중할 수 있다.
### 구체적 프로그래밍.
버그 없는 프로그램을 만드는 데 필수적인 것은, 시스템의 제어 구조를 개별적인 분기문이 아니라 그야말로 제어 구조로 생각해야 한다는 점이다.

## 2. 구성 요소 디버깅
프로그램을 디버깅하는 절차는 지난 20년에 걸쳐 커다란 주기를 자나왔고, 어떤 면에서는 출발했던 곳으로 다시 돌아와 있다. 그 주기안에의 네 단계가 있는데 하나씩 따라가며 등장하게된 동기를 알아보자.  
### 온-머신 디버깅.
초창기 컴퓨터들은 입출력 장치가 상대적으로 빈약했고 입력과 출력 간의 시간 간격도 길었다.  
프로그래머는 디버깅을 할 때 실행을 어디서 중단하고, 메모리의 어느 곳을 조사ㅎ랄 것이면, 거기서 무엇을 찾아야 하고, 만약 찾지 못하면 어떻게 할 것인지 같은 절차를 주의 깊게 설계했다.  
### 메모리 덤프
각 메모리 주소의 내용을 해명하기 위한 고된 서류 작업이 시작되었다. 이 작업은 온-머신 디버깅 때와 그다지 다를 바 없지만, 테스트 수행 전의 계획 단계가 아니라 테스트 후의 해독 단계라는 차이가 있었다.
### 스냅샷.
메모리 용량이 극적으로 증대되면서 전체 메모리를 덤프한다는 것은 비현실적인 일이 되었다. 그래서 선택적덤프, 선택적 추적, 프로그램 내 스냅샷 삽입 같은 기법이 개발되었다.  
### 대화식 디버깅.
고급언어로 프로그램을 짜고 디버깅할 수 있게 되었으며, 효율적인 편집 도구는 프로그램 변경과 스냅샷 작업을 쉽게 해준다.  
즉각적인 회송이라는 온-머신 디버깅의 장점으로 다시 돌아왔다.(디버깅 세션 전의 사전 준비까지도 다시 필요하게 된 것은 아니다)  
### 테스트 케이스
## 3. 시스템 디버깅
프로그래밍 시스템을 만들 때 의외로 어려운 부분이 시스템 테스트다.  
시스템 디버깅은 예상보다 오래 걸릴 것이다. 그리고 디버깅은 그 어려움 때문에 철저히 체계적이고 계획적인 접근이 필요하다.  
이제 이런 접근법은 어떻게 이루어지는지 살펴보자.  
### 디버깅된 구성 요소를 사용하라.
상식적으로 생각할 때 시스템 디버깅은 각 부분이 제대로 동작하게 된 다음에 시작하는 것이 타당하다.  
실제 관례는 두 가지 면에서 이런 상식으로 벗어난다.
- 일단 조립하고 보자는 식의 접근법 : 디버깅되어 깨끗한 상태의 구성 요소를 사용함으로써 시스템 테스트에서 얻는 시간적 이득은, 비계를 만들고 구성 요소를 철저히 테스트하는 데 소요된 시간보다도 훨씬 크다.
- '문서화된 버그'접근법 : 발견된 버그에 의한 효과가 어떤것인지는 파악된 상태이므로, 시스템 테스팅에 들어가서는 그런 효과를 무시하고 새로운 현상에 집중할 수 있다는것이다.   

그러나 이 모든 이야기는 단지 늦어진 일정을 합리화하고자 만들어낸 희망 사항일 뿐이다.
### 비계를 많이 만들라.
비계는 디버깅을 목적으로 만들어졌지만 최종 제품에 포함될 일은 전혀 없는 프로그램과 데이터를 두루 일컫는 말.  
비계의 코드 분량이 제품 코드의 절반에 이르는 것은 그리 이상한 일이 아니다.  
### 변경을 통제하라.
모든 변경 사항을 일지에 기록해두는 것, 그리고 충분한 검토와 테스트와 문서화를 거친 수정 사항과 응급조치 간의 차이점을 소스 코드상에 두드러지도록 구분해두는 것이다.
### 구성 요소 추가는 한번에 하나씩.
완전한 테스트 케이스를 확보해 두고 새로운 요소가 추가될 때 마다 시스템의 해당 부분을 테스트해야 한다는 점이다. 또, 다른 요소들이 바로 전까지 잘 동작했다 해도, 새 요소가  추가 된 후에는 회귀 테스트를 통해 다시 검사되어야 한다. 
### 변경은 묶음으로.
테스트베드가 변경될 경우 그들의 작업은 지연될 것이다. 변경 사항들은 묶어서 처리될 필요가 았다. 그렇게 함으로써 개발자들은 테스트베드의 돌발적인 변경이라는 방해 요소 사이사이에 생산성 높은 안정기를 확보할 수 있게 된다.  
