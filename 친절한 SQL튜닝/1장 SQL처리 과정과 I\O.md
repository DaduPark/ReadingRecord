# 1장 SQL처리 과정과 I/O
## 1.1 SQL파싱과 최적화
- 옵티마이저가 SQL을 어떻게 처리하는지, 서버프로세스는 데이터를 어떻게 일고 저장하는지 살펴보자
### 1.1.1 구조적, 집합적, 선언적 질의언어
- SQL은 구조적이고 집합적이고 선언적인 질의 언어
- 결과를 만들기위해 프로시저가 필요한데 그 프로시저를 만들어내는 DBMS 내부엔진이 바로 **SQL 옵티마이저**이다.
  
### 1.1.2 SQL 최적화
> DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행가능한 상태로 만드는 전 과정  
> 사용자 SQL전달 > SQL 파싱 > SQL 최적화 > 로우 소스 생선 순으로 진행
1. SQL 파싱
   - 파싱 트리 생성
   - Syntax 체크 : 문법적 오류가 없는지 확인
   - Sematic 체크 : 의미상 오류가 없는지 확인
2. SQL 최적화 (**옵티마이저**)
   - 미리 수집한 시스템 및 통계정보를 바탕으로 실행경로를 생성한 후 가장 효율적인 것으로 선택  
   - 최적화 단계 : 후보군이 될만한 실횡계획 찾기 -> 데이터 딕셔너리에 미리 수집해둔 통계를 이용하여 실행계획의 비용 산정 -> 최적의 실행계획 선택
3. 로우 소스 생성
   - 실행 가능한 코드, 프로시저 형태로 포맷팅하는 단계

### 1.1.4 실행계획과 비용
- 실행계획 : SQL 옵티마이저가 생성한 처리 절차를 트리구조로 표현한 것
- 최적의 선택 근거 : : 비용 즉, 예상한 I/O 횟수 또는 예상 소요시간을 표현한 값
- BUT, 실행계획에 표시된 Cost도 예상치이므로 실수행과 차이가 날 수 있음

### 1.1.4 옵티마이저 힌트 
- 개발자가 데이터 엑세스 경로를 바꾸는 것
- 사용 예) select /*+ INDEX(A 고객_PK)*/ 컬럼명...;
- 주의사항
  -  ','(콤마)는 힌트 안의 인자를 나열할때만 쓰고 힌트와 힌트 사이 사용은 안된다.
  -  테이블 ALIAS 지정 시, 힌트에도 반드시 ALIAS 사용
- 기왕 힌트를 사용 한다면 빈틈없이 기술해야 한다.
<img height="400" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/673d612e-cf3f-4719-8516-d87434655116">
<img height="400" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/632e2195-fdd9-4579-af97-67a2cc95fb89">

---
## 1.2 SQL 공유 및 재사용
### 1.2.1 소프트파싱 VS 하드파싱
- 라이브러리 캐시(Library Cache)
  - SQL 파싱, 최적호, 로우 소스 생성과정을 거쳐 생성한 내부 프로시저를 반복 재사용 할 수 있도록 캐싱 해두는 메모리 공간
  - SGA 구성요소
- SQL실행 순서 : SQL이 라이브러리 캐시에 존재하는지 확인  
  <img height="150" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/a9e2f6c3-d0bb-4028-b8da-79d5417483c0">  
- 소프트 파싱 : SQL을 캐시에서 찾아 바로 실행단계로 진행
- 하드 파싱 : 캐시에서 찾지 못하여 최적화 및 로우 생성 단계까지 모두 거치는 것
   - 최적화에서 엄청나게 많은 연산을 진행하여 CPU가 많은 소비가 된다(라이브러리 캐시가 필요한 이유)
### 1.2.2 바인드 변수의 중요성
- 사용자 정의함수, 프로시저, 트리거, 패키지 등은 생성할때 부터 **이름**을 가져 딕셔너리에 저장되며 영구 보관된다. 그러므로 라이브러리 캐시에 적재하여 재사용된다.
- SQL은 텍스트 전체가 이름 역할 즉, 작은 부분이라도 수정되면 다른 객체로 탄생됨(SQL ID도 변한다)
- 하단 예시는 모두 다른 ID로 처리됨 => **하드 파싱**처리됨
  ```sql
  select * from emp where empno = 11;
  Select * from emp where empno = 11;
  select * from emp where empno = 12;  
  ```
- **바인드 변수**를 사용함으로써 캐싱된 SQL을 사용자마다 공유하여 하드파싱은 한번만 일어난다.
  ```sql
  select * from emp where empno = :empno;
  ```
