# 1장 SQL처리 과정과 I/O
## 1.1 SQL파싱과 최적화
- 옵티마이저가 SQL을 어떻게 처리하는지, 서버프로세스는 데이터를 어떻게 일고 저장하는지 살펴보자
### 1.1.1 구조적, 집합적, 선언적 질의언어
- SQL은 구조적이고 집합적이고 선언적인 질의 언어
- 결과를 만들기위해 프로시저가 필요한데 그 프로시저를 만들어내는 DBMS 내부엔진이 바로 **SQL 옵티마이저**이다.
  
### 1.1.2 SQL 최적화
> DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행가능한 상태로 만드는 전 과정  
> 사용자 SQL전달 > SQL 파싱 > SQL 최적화 > 로우 소스 생선 순으로 진행
1. SQL 파싱
   - 파싱 트리 생성
   - Syntax 체크 : 문법적 오류가 없는지 확인
   - Sematic 체크 : 의미상 오류가 없는지 확인
2. SQL 최적화 (**옵티마이저**)
   - 미리 수집한 시스템 및 통계정보를 바탕으로 실행경로를 생성한 후 가장 효율적인 것으로 선택  
   - 최적화 단계 : 후보군이 될만한 실횡계획 찾기 -> 데이터 딕셔너리에 미리 수집해둔 통계를 이용하여 실행계획의 비용 산정 -> 최적의 실행계획 선택
3. 로우 소스 생성
   - 실행 가능한 코드, 프로시저 형태로 포맷팅하는 단계

### 1.1.4 실행계획과 비용
- 실행계획 : SQL 옵티마이저가 생성한 처리 절차를 트리구조로 표현한 것
- 최적의 선택 근거 : : 비용 즉, 예상한 I/O 횟수 또는 예상 소요시간을 표현한 값
- BUT, 실행계획에 표시된 Cost도 예상치이므로 실수행과 차이가 날 수 있음

### 1.1.4 옵티마이저 힌트 
- 개발자가 데이터 엑세스 경로를 바꾸는 것
- 사용 예) select /*+ INDEX(A 고객_PK)*/ 컬럼명...;
- 주의사항
  -  ','(콤마)는 힌트 안의 인자를 나열할때만 쓰고 힌트와 힌트 사이 사용은 안된다.
  -  테이블 ALIAS 지정 시, 힌트에도 반드시 ALIAS 사용
- 기왕 힌트를 사용 한다면 빈틈없이 기술해야 한다.
<img height="400" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/673d612e-cf3f-4719-8516-d87434655116">
<img height="400" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/632e2195-fdd9-4579-af97-67a2cc95fb89">

---
## 1.2 SQL 공유 및 재사용
### 1.2.1 소프트파싱 VS 하드파싱
- 라이브러리 캐시(Library Cache)
  - SQL 파싱, 최적호, 로우 소스 생성과정을 거쳐 생성한 내부 프로시저를 반복 재사용 할 수 있도록 캐싱 해두는 메모리 공간
  - SGA 구성요소
- SQL실행 순서 : SQL이 라이브러리 캐시에 존재하는지 확인  
  <img height="150" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/a9e2f6c3-d0bb-4028-b8da-79d5417483c0">  
- 소프트 파싱 : SQL을 캐시에서 찾아 바로 실행단계로 진행
- 하드 파싱 : 캐시에서 찾지 못하여 최적화 및 로우 생성 단계까지 모두 거치는 것
   - 최적화에서 엄청나게 많은 연산을 진행하여 CPU가 많은 소비가 된다(라이브러리 캐시가 필요한 이유)
### 1.2.2 바인드 변수의 중요성
- 사용자 정의함수, 프로시저, 트리거, 패키지 등은 생성할때 부터 **이름**을 가져 딕셔너리에 저장되며 영구 보관된다. 그러므로 라이브러리 캐시에 적재하여 재사용된다.
- SQL은 텍스트 전체가 이름 역할 즉, 작은 부분이라도 수정되면 다른 객체로 탄생됨(SQL ID도 변한다)
- 하단 예시는 모두 다른 ID로 처리됨 => **하드 파싱**처리됨
  ```sql
  select * from emp where empno = 11;
  Select * from emp where empno = 11;
  select * from emp where empno = 12;  
  ```
- **바인드 변수**를 사용함으로써 캐싱된 SQL을 사용자마다 공유하여 하드파싱은 한번만 일어난다.
  ```sql
  select * from emp where empno = :empno;
  ```
---
## 1.3 데이터 저장 구조 및 I/O 메커니즘
### 1.3.1 SQL이 느린 이유
- 디스크를 통해 데이터를 I/O할때 CPU를 OS에 반환하고 잠시 수면(waiting)상태에서 I/O가 완료되기를 기다린다. 즉 일해야 할 프로세스가 수면상태로 되어 I/O가 많으면 성능이 느려짐
- SQL이 느린 이유도 디스크 I/O 때문

### 1.3.2 데이터베이스 저장 구조  
<img width="300" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/f6dd4eb5-070d-4237-bf36-60f706ee45f3">  

<img width="486" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/0dd53276-4f7d-43ab-bc4d-8e5532325264">  

- 블록 
  - DBMS가 데이터를 읽고 쓰는 단위
  - 한 블록에 저장된 레크드는 모두 같은 테이블 레코드
  - 한 익스텐트에 담긴 블록은 모두 같은 테이블 블록
  - 오라클은 기본 8KB 
  - 테이블 뿐 아니라 인덱스도 블록단위로 데이터를 읽고 쓴다.
- 익스텐트
  - 공간을 확장하는 단위. 연속된 블록 집합
  - 서로 다른 데이터 파일에 위치할 가능성이 높다(파일 경합을 줄이기 위해 여러 데이터파일로 분산 저장)
  - 인스텐트 내 블록은 서로 인접한 연속된 공간 / 익스텐트끼리는 연속된 공간이 아니다
- 세그먼트 
  - 데이터 저장공간이 필요한 오브젝트(테이블, 인덱스, 파티션, LOB 등)
  - 테이블이나 인덱스가 파티션 구조일 시 각 파티션이 하나의 세그먼트
- 테이블스페이스 
  - 세그먼트를 담는 콘테이너
  - 여러개의 데이터파일로 구성
- 데이터 파일 : 디스크상의 물리적인 OS 파일

### 1.3.4 시퀀셜 액세스 VS 랜덤 액세스
- 시퀀셜 액세스
  -  논리적, 물리적으로 연결된 순서에 따라 차례로 읽고 쓰는 방식
  -  인덱스 리프 블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 서로 연결되어있음
  -  Full Table Scan시 사용
- 랜덤 엑세스
  - 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식
  - 인덱스에서 테이블 엑세스 하는것도 랜덤 엑세스
  - 
### 1.3.5 논리적 I/O VS 물리적 I/O
- 서버프로세스와 데이터파일 사이에 **DB 버퍼 캐시**가 있어 데이터파일을 통해 한번 읽은 데이터를 저장한다.(버퍼캐시는 공유메모리 영역이므로 같은 블록을 읽는 다른 프로세스도 득을 본다)
- DB버퍼캐시는 **데이터 캐시**라고 할 수 있다.(라이브러리 캐시는 코드 캐시라고 할 수 있다.)
- 논리적 I/O
   - SQL문 처리과정에서 메모리 버퍼 캐시에서 발생한 총 블록 I/O
- 물리적 I/O
   - 버퍼캐시에서 존재하지 않아 디스크를 읽은 총 I/O
   - 상당히 느림
   - 물리적 I/O = 논리적 I/O x (100 - BCHR)
   - BCHR : 버퍼캐시히트율
- 물리적 I/O는 시스템 상황에 의해 결정되는 통제 불가능한 외생변수
- SQL성능을 높이기 위해서 할 수 있는 일은 논리적 I/O를 줄이는 일 뿐이다 (I/O자체를 줄이라는 뜻)

### 1.3.6 Single Block I/O VS Multiblock I/O
- Single Block I/O
  - 한 블록씩 요청해서 메모리에 적재하는 방식
  - 인덱스를 이용할때 기본적으로 사용
- Multiblock I/O
  - 한번에 여러 블록씩 요청해서 메모리에 적재하는 방식
  - 테이블 전체 스캔할때 사용
  - 여러 블록을 요청함으로써 프로세스의 대기 큐(wait queue)를 줄여 성능을 높일 수 있다
  - 여러 인스텐트에 존재하는 값을 가져오지못한다. 즉 한 인스텐트의 값을 가져옴
 
### 1.3.7 Table Full Scan VS Index Range Scan
- Table Full Scan
   - 테이블 전체 스캔
   - 시퀀셜 액세스와 Multiblock I/O 사용
- Index Range Scan
   - 인덱스를 이용해서 읽는 방식
   - 랜덤 엑세스와 Single Block I/O 사용

- 인덱스 사용은 중요하나 읽을 데이터의 일정량이 넘으면 인덱스보다 Table Full Scan이 더 유리하다
