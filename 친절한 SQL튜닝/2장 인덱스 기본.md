# 인덱스 기본

## 2.1 인덱스 구조 및 탐색
- 인덱스 구조와 탐색 원리 설명
- 인덱스 탐색 과정 : 수직적 탐색, 수평적 탐색

### 2.1.1 미리보는 인덱스 튜닝
- 인덱스 튜팅의 핵심요소
    - 인덱스 스캔 효율화 튜닝 
    - **랜덤 액세스(인덱스 스캔 후 테이블 레코드를 액세스) 최소화 튜닝** (성능에 더 중요)
 
### 2.1.2 인덱스 구조
- 인덱스
  - 대용량 테이블에서 **필요한 데이터만 빠르게 효율적으로 엑세스**하기 위해 사용하는 오브젝트  
  - 인덱스를 이용하면 일부만 멈출수 있다(범위스캔_Range Scan) 인덱스가 정렬돼 있기 때문이다.
- B-Tree 인덱스
  - 나무를 거꾸로 뒤집은 모양[루트-브랜치-리프]
  - 루트와 브랜치
    - 루트와 브랜치 블록에 있는 각 레코드는 하위 블록에 대한 주소값을 갖는다. 키값은 하위 블록에 저장된 키값의 범위를 나타낸다.
    - 루트와 브랜치 블록에는 키값을 갖지 않는 레코드인 LMC(Leftmost Child)를 가지고 있다.
    - LMC는 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다. 즉, LMC가 가리키는 주소로 찾아간 블록에는 키값을 가진 첫 번째 레코드보다 작거나 같은 레코드가 저장돼 있다.
  - 리프 블록
    - 리프블록은 키값 순으로 정렬돼 있으며 테이블 레코드를 가리키는 주소값인 ROWID를 갖는다.
    - 인덱스 스캔 이유 : 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 ROWID를 얻기 위해
  - ROWID
    - ROWID = 데이터 블록 주소 + 로우 번호
    - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
    - 블록 번호 : 데이터파일 내에서 부여한 상대적 순번
    - 로우 번호 : 블록 내 순번
- 인덱스 탐색 과정
   - 수직적 탐색
      -  인덱스 스캔 시작점을 찾는과정
      -  루트, 브랜치은 각 인덱스 레코드의 하위 블록에 대한 주소값을 갖기 때문에 수직적 탐색이 가능
      -  조건을 만족하는 첮번째 레코드를 찾는 과정
   - 수평적 탐색
     - 데이터를 찾는 과정(리프 블록을 수평적으로 수평)
     - 조건절을 만족하는 데이터를 모두 찾고 ROWID를 얻기 위해 탐색

### 2.1.5 결할 인덱스 구조 탐색
- 두개 이상 컬럼을 결합해서 인덱스를 만들 수 있음
- 선택도가 낮은 컬럼을 앞쪽에 두고 결합인덱스를 생성해야 성능이 좋다
  - 예) [성별+이름 성능] <  [이름+성별 성능]
  -  50명중 성별로 25명을 거르고 이름으로는 2명으로 거를 수 있다.

---
## 2.2 인덱스 기본 사용법
- 인덱스 기본 사용법 학습 즉, Range Scan하는 법 학습한다.

### 2.2.1 인덱스를 사용한다는 것
- 리프 블록 일부만 스캔하는 Index Range Scan을 의미
- 인덱스 컬럼을 **가공**할 경우 리프 블록 전체(Index Full Scan)를 스캔해야한다.

### 2.2.1 인덱스를 Range Scan 할 수 없는 이유
- Range Scan은 인덱스를 일정 법위를 스캔한다는 뜻
- 가공된 인덱스는 시작, 끝지점을 찾을 수 없으므로 멈추지 못한다(YYMMDD란 생일 인덱스 컬럼이 있는데 년도와 상관없이 6월에 태어난 사람을 찾을 경우)
```sql
where substr(생년월일, 5, 2) = '05' 
where nvl(주문수량, 0) < 100
where 업체명 like '%대한%'
```
- 위 세개 모두 가공된 인덱스라 Range scan이 불가
```sql
where (전화번호 = : tel_no or 고객명 = : cust nm)
```
- or은 할 수 없으나 옵티마이저가 Union all 형태인 OR Expansion을 유도할 경우 Range Scan을 작동할 수 있다
```sql
where 전화번호 in ( : tel_no1, : tel_no2 )
```
- Union all 형태인 IN-List Iterator 방식을 사용하면 가능, IN-List 개수 만큰 Range Scan을 진행한다.

### 2.2.3 더 중요한 인덱스 사용 조건 
- **선행조건**은 인덱스를 정상적으로 사용하는데 중요한 조건이다.
- 인덱스를 Range Scan 하기 위한 조건
  - 조건절에 선두 컬럼이 존재해야된다.
  - 선두 컬럼이 가공되지 않은 상태로 있어야한다

### 2.2.4 인덱스를 이용한 소트 연산 생략
- 인덱스를 Range Scan 할 수 있는 이유는 데이터가 **정렬**돼 있기 때문이다.
- 정렬되어 있기 때문에 인덱스값으로 ORDER BY 연산을 해도 소트 연산(SORT) 생략도 가능하다
- ORDER BY 연산에서 인덱스를 가공했거나 EX) ORDER BY 변경일자||변경선번
- SELECT-LIST의 가공된 컬럼을 ORDER BY 연산에 사용할 경우 소트 연산(SORT) 생략도 불가능하다
```sql
SELECT TO_CHAR(A.주문번호, 'FM000') AS 주문번호 FROM 주문 A ORDER BY 주문번호)
```

### 2.2.6 SELECT-LIST에서 컬럼 가공
- 최소값(MIN), 최대값(MAX)를 구할 때 인덱스를 이용하면 수직적 탐색을 통해가장 왼쪽이나 오른쪽 지점을 찾으면 되므로 **레코드 하나(FIRST ROW)**만 일고 멈춘다.
- 그러나 가공된 컬럼사용시 정렬 연산을 생략할 수 없다.  
   EX) NVL(MAX(TO_NUMBER(변경순번))

### 2.2.7 자동 형변환
- 옵티마이저가 자동형변환 할 경우 인덱스 컬럼이 가공되어 Range Scan을 할 수 없다.
- 숫자형과 문자형이 만나면 숫자형이 이긴다  
  EX) 생년월일 = 19930608  -(자동형변환)-> TO_NUMBER(생년월일) = 19930608
- 날짜형과 문자형이 만나면 날짜 형이 이긴다. 예시에서는 인덱스를 못타진 않지만 설정환경에 따라 날짜형이 달라지므로 컴파일 오류가 생길 가능성이 있다.
  EX) 가입일짜 = '01-JAN-2018' -(자동형변환)->  가입일짜 = TO_DATE('01-JAN-2018', 'DD-MON-YYYY')
- LIKE 사용 시 문자형 기준으로 숫자형 컬럼이 변환된다.
  EX) 고객번호 LIKE '9403%' -(자동형변환)-> TO_CHAR(고객번호) LIKE '9403%'
- decode 함수를 처리(decode(a,b,c,d))할때 d값은 세 번째 인자인 c에 의해 결정되므로 주의 해야한다.
- 형변환함수(TO_CHAR, TO_DATE, TO_NUMBER)을 사용한다해서 성능이 안좋아지지 않으며 성능은 블록 I/O를 줄이는 것이 중요하다.
