# 인덱스 기본

## 2.1 인덱스 구조 및 탐색
- 인덱스 구조와 탐색 원리 설명
- 인덱스 탐색 과정 : 수직적 탐색, 수평적 탐색

### 2.1.1 미리보는 인덱스 튜닝
- 인덱스 튜닝의 핵심요소
    - 인덱스 스캔 효율화 튜닝 
    - **랜덤 액세스(인덱스 스캔 후 테이블 레코드를 액세스) 최소화 튜닝** (성능에 더 중요)
 
### 2.1.2 인덱스 구조
- 인덱스
  - 대용량 테이블에서 **필요한 데이터만 빠르게 효율적으로 엑세스**하기 위해 사용하는 오브젝트  
  - 인덱스를 이용하면 일부만 멈출수 있다(범위스캔_Range Scan) 인덱스가 정렬돼 있기 때문이다.
- B-Tree 인덱스
  - 나무를 거꾸로 뒤집은 모양[루트-브랜치-리프]
  - 루트와 브랜치
    - 루트와 브랜치 블록에 있는 각 레코드는 하위 블록에 대한 주소값을 갖는다. 키값은 하위 블록에 저장된 키값의 범위를 나타낸다.
    - 루트와 브랜치 블록에는 키값을 갖지 않는 레코드인 LMC(Leftmost Child)를 가지고 있다.
    - LMC는 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다. 즉, LMC가 가리키는 주소로 찾아간 블록에는 키값을 가진 첫 번째 레코드보다 작거나 같은 레코드가 저장돼 있다.
  - 리프 블록
    - 리프블록은 키값 순으로 정렬돼 있으며 테이블 레코드를 가리키는 주소값인 ROWID를 갖는다.
    - 인덱스 스캔 이유 : 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 ROWID를 얻기 위해
  - ROWID
    - ROWID = 데이터 블록 주소 + 로우 번호
    - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
    - 블록 번호 : 데이터파일 내에서 부여한 상대적 순번
    - 로우 번호 : 블록 내 순번
- 인덱스 탐색 과정
   - 수직적 탐색
      -  인덱스 스캔 시작점을 찾는과정
      -  루트, 브랜치은 각 인덱스 레코드의 하위 블록에 대한 주소값을 갖기 때문에 수직적 탐색이 가능
      -  조건을 만족하는 첮번째 레코드를 찾는 과정
   - 수평적 탐색
     - 데이터를 찾는 과정(리프 블록을 수평적으로 수평)
     - 조건절을 만족하는 데이터를 모두 찾고 ROWID를 얻기 위해 탐색

### 2.1.5 결할 인덱스 구조 탐색
- 두개 이상 컬럼을 결합해서 인덱스를 만들 수 있음
- 선택도가 낮은 컬럼을 앞쪽에 두고 결합인덱스를 생성해야 성능이 좋을 것처럼 보이지만 같다
  - 예) [성별+이름 성능] =  [이름+성별 성능]
  -  50명중 성별로 25명을 거르고 이름으로는 2명으로 거를 수 있다.

---
## 2.2 인덱스 기본 사용법
- 인덱스 기본 사용법 학습 즉, Range Scan하는 법 학습한다.

### 2.2.1 인덱스를 사용한다는 것
- 리프 블록 일부만 스캔하는 Index Range Scan을 의미
- 인덱스 컬럼을 **가공**할 경우 리프 블록 전체(Index Full Scan)를 스캔해야한다.

### 2.2.1 인덱스를 Range Scan 할 수 없는 이유
- Range Scan은 인덱스를 일정 법위를 스캔한다는 뜻
- 가공된 인덱스는 시작, 끝지점을 찾을 수 없으므로 멈추지 못한다(YYMMDD란 생일 인덱스 컬럼이 있는데 년도와 상관없이 6월에 태어난 사람을 찾을 경우)
```sql
where substr(생년월일, 5, 2) = '05' 
where nvl(주문수량, 0) < 100
where 업체명 like '%대한%'
```
- 위 세개 모두 가공된 인덱스라 Range scan이 불가
```sql
where (전화번호 = : tel_no or 고객명 = : cust nm)
```
- or은 할 수 없으나 옵티마이저가 Union all 형태인 OR Expansion을 유도할 경우 Range Scan을 작동할 수 있다
```sql
where 전화번호 in ( : tel_no1, : tel_no2 )
```
- Union all 형태인 IN-List Iterator 방식을 사용하면 가능, IN-List 개수 만큰 Range Scan을 진행한다.

### 2.2.3 더 중요한 인덱스 사용 조건 
- **선행조건**은 인덱스를 정상적으로 사용하는데 중요한 조건이다.
- 인덱스를 Range Scan 하기 위한 조건
  - 조건절에 선두 컬럼이 존재해야된다.
  - 선두 컬럼이 가공되지 않은 상태로 있어야한다

### 2.2.4 인덱스를 이용한 소트 연산 생략
- 인덱스를 Range Scan 할 수 있는 이유는 데이터가 **정렬**돼 있기 때문이다.
- 정렬되어 있기 때문에 인덱스값으로 ORDER BY 연산을 해도 소트 연산(SORT) 생략도 가능하다
- ORDER BY 연산에서 인덱스를 가공했거나 EX) ORDER BY 변경일자||변경선번
- SELECT-LIST의 가공된 컬럼을 ORDER BY 연산에 사용할 경우 소트 연산(SORT) 생략도 불가능하다
```sql
SELECT TO_CHAR(A.주문번호, 'FM000') AS 주문번호 FROM 주문 A ORDER BY 주문번호)
```

### 2.2.6 SELECT-LIST에서 컬럼 가공
- 최소값(MIN), 최대값(MAX)를 구할 때 인덱스를 이용하면 수직적 탐색을 통해가장 왼쪽이나 오른쪽 지점을 찾으면 되므로 **레코드 하나(FIRST ROW)**만 일고 멈춘다.
- 그러나 가공된 컬럼사용시 정렬 연산을 생략할 수 없다.  
   EX) NVL(MAX(TO_NUMBER(변경순번))

### 2.2.7 자동 형변환
- 옵티마이저가 자동형변환 할 경우 인덱스 컬럼이 가공되어 Range Scan을 할 수 없다.
- 숫자형과 문자형이 만나면 숫자형이 이긴다  
  EX) 생년월일 = 19930608  -(자동형변환)-> TO_NUMBER(생년월일) = 19930608
- 날짜형과 문자형이 만나면 날짜 형이 이긴다. 예시에서는 인덱스를 못타진 않지만 설정환경에 따라 날짜형이 달라지므로 컴파일 오류가 생길 가능성이 있다.
  EX) 가입일짜 = '01-JAN-2018' -(자동형변환)->  가입일짜 = TO_DATE('01-JAN-2018', 'DD-MON-YYYY')
- LIKE 사용 시 문자형 기준으로 숫자형 컬럼이 변환된다.
  EX) 고객번호 LIKE '9403%' -(자동형변환)-> TO_CHAR(고객번호) LIKE '9403%'
- decode 함수를 처리(decode(a,b,c,d))할때 d값은 세 번째 인자인 c에 의해 결정되므로 주의 해야한다.
- 형변환함수(TO_CHAR, TO_DATE, TO_NUMBER)을 사용한다해서 성능이 안좋아지지 않으며 성능은 블록 I/O를 줄이는 것이 중요하다.
---

## 2.3 인덱스 확장기능 사용법
- 각 스캔 방식의 주요 특징 설명

### 2.3.1 Index Range Scan
- B-tree 인덱스의 가장 일반적인 엑세스 방식
- 수직적 탐색 후에 '필요한 범위만' 스캔  
<img width="300" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/f0c69e9c-0449-4c39-be10-b0c15adc2a30">

### 2.3.2 Index Full Scan
- 수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색
- 인덱스 컬럼 순으로 정렬 되어 있어 Sort Order By 연산을 생락 할 목적으로 사용할 수도 있다.
- 인덱스 **선두 컬럼**을 조건절에서 사용하지 않으면 옵티마이저가 기본적으로 Table Full Scan을 선택하지만 Full스캔보다 I/O를 줄일 수 있으면 Index Full Scan을 사용하기도 한다.
- fetch를 멈추지 않고 데이터를 끝까지 읽는다면 Table Full Scan보다 훨씬 많은 I/O를 일으켜 더 느려질 수 있기때문에 주의도 필요하다.  
<img width="300" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/ee199b49-0e6e-4989-acef-b18746b61706">

### 2.3.3 Index Unique Scan
- 수직적 탐색만으로 데이터를 찾는 스캔 방식
- Unique인덱스이므로 데이터 한 건은 찾는 순간 더 이상 탐색할 필요가 없다.
- 범위검색 조건에서는 Unique인덱스라 하더라도 Index Range Scan으로 처리된다.  
<img width="300" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/5794025c-2d61-4ea1-a868-5039581b97d4">

### 2.3.4 Index Skip Scan
- Distinct Value개수가 적은 선두 컬럼(성별 등)이 조건절에 없고 후행 컬럼의 Distinct Value 개수가 많을때(연봉 등) 사용  
<img width="300" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/554a69b2-8d00-490d-825b-c04bdf361b74">

### 2.3.5 Index Fast Full Scan
- Index Full Scan 보다 빠르다
- 논리적 인덱스 트리 구조를 무시하고 인덱스 세크먼트 전체를 MultilBlock I/O방식으로 스캔하기 때문이다(물리적으로 디스크에 저장된 순서대로 읽기 때문)  
<img width="600" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/163df7d9-c225-4ce6-9f41-b7abe73e3a5f">

### 2.3.6 Index Range Scan Descending
- Index Range Scan과 기본적으로 동일한 스캔 방식
- 내림차순으로 정렬된 결과집합을 얻는다.(인덱스를 거꾸로 읽는 실행계획 수립)
<img width="300" alt="image" src="https://github.com/DaduPark/ReadingRecord/assets/76692927/71eabfdf-59f7-4b00-98e2-45c5e0cc9c62">


