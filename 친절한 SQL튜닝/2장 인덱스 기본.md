# 인덱스 기본

## 2.1 인덱스 구조 및 탐색
- 인덱스 구조와 탐색 원리 설명
- 인덱스 탐색 과정 : 수직적 탐색, 수평적 탐색

### 2.1.1 미리보는 인덱스 튜닝
- 인덱스 튜팅의 핵심요소
    - 인덱스 스캔 효율화 튜닝 
    - **랜덤 액세스(인덱스 스캔 후 테이블 레코드를 액세스) 최소화 튜닝** (성능에 더 중요)
 
### 2.1.2 인덱스 구조
- 인덱스
  - 대용량 테이블에서 **필요한 데이터만 빠르게 효율적으로 엑세스**하기 위해 사용하는 오브젝트  
  - 인덱스를 이용하면 일부만 멈출수 있다(범위스캔_Range Scan) 인덱스가 정렬돼 있기 때문이다.
- B-Tree 인덱스
  - 나무를 거꾸로 뒤집은 모양[루트-브랜치-리프]
  - 루트와 브랜치
    - 루트와 브랜치 블록에 있는 각 레코드는 하위 블록에 대한 주소값을 갖는다. 키값은 하위 블록에 저장된 키값의 범위를 나타낸다.
    - 루트와 브랜치 블록에는 키값을 갖지 않는 레코드인 LMC(Leftmost Child)를 가지고 있다.
    - LMC는 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다. 즉, LMC가 가리키는 주소로 찾아간 블록에는 키값을 가진 첫 번째 레코드보다 작거나 같은 레코드가 저장돼 있다.
  - 리프 블록
    - 리프블록은 키값 순으로 정렬돼 있으며 테이블 레코드를 가리키는 주소값인 ROWID를 갖는다.
    - 인덱스 스캔 이유 : 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 ROWID를 얻기 위해
  - ROWID
    - ROWID = 데이터 블록 주소 + 로우 번호
    - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
    - 블록 번호 : 데이터파일 내에서 부여한 상대적 순번
    - 로우 번호 : 블록 내 순번
- 인덱스 탐색 과정
   - 수직적 탐색
      -  인덱스 스캔 시작점을 찾는과정
      -  루트, 브랜치은 각 인덱스 레코드의 하위 블록에 대한 주소값을 갖기 때문에 수직적 탐색이 가능
      -  조건을 만족하는 첮번째 레코드를 찾는 과정
   - 수평적 탐색
     - 데이터를 찾는 과정(리프 블록을 수평적으로 수평)
     - 조건절을 만족하는 데이터를 모두 찾고 ROWID를 얻기 위해 탐색

### 2.1.5 결할 인덱스 구조 탐색
- 두개 이상 컬럼을 결합해서 인덱스를 만들 수 있음
- 선택도가 낮은 컬럼을 앞쪽에 두고 결합인덱스를 생성해야 성능이 좋다
  - 예) [성별+이름 성능] <  [이름+성별 성능]
  -  50명중 성별로 25명을 거르고 이름으로는 2명으로 거를 수 있다.


