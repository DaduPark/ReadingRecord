# 인덱스 튜닝
## 3.1 테이블 액세스 최소화
- 테이블 랜덤 액세스를 최소화하는 구체적인 방법들 소개
### 3.1.1 테이블 랜덤 엑세스
- 인덱스 ROWID는 물리적 주소가 아닌 논리적 주소이며 디스크 상에서 테이블 레코드르 찾아가기 위한 위치 정보를 담는다. ROWID를 이용한 테이블 액세스가 생각만큼 빠르지 않다 (프로그래밍에서의 물리적주소인 포인터와 다름)
- I/O 성능을 높이려면 버퍼캐시를 활용해야한다. ROWID가 가리키는 테이블 블록 버퍼캐시를 먼저 찾고 못찾을 때는 디스크 블록을 읽는다. 모든 데이터가 캐싱 돼있어도 테이블 레코드르 찾기 위해 매번 DBA해싱과 래치 획득 과정을 반복해는 등 **인덱스 ROWID를 이용한 테이블 엑세스는 생각보다 고비용 구조다**

### 3.1.2 인덱스 클러스터링 팩터
- 클러스터링 팩터(CF)는 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다.
- 인덱스는 검색효율이 매우 좋다.
- CF가 좋은 인덱스 사용시 블록 I/O가 적게 발생하는 이유 : 인덱스 ROWID로 테이블 액세스 할때 래치 획득과 해시 체인 스캔 과정을 거쳐 어럽게 찾아간 테이블 블록에대한 포인터를 해제하지 않고 일단 유지한다(버퍼 Pinning), 다음 인덱스 코드를 읽었을때 '직전과 같은 테이블 블록을 가리킨다'
[사진]

 ### 3.1.3 인덱스 손익 분기점
 - Table Full Scan은 1000만 건중 한건이든 10만건조회이든 성능은 일정하다.
 - Table Full Scan : 시퀀스 엑세스, Multiblock I/O
 - 인덱스 ROWID 이용 테이블 액세스 : 랜덤 액세스, Single Block I/O
 - 읽어야 할 데이터가 일정량을 넘는 순간, 테이블 전체를 스캔한 것보다 느려진다.(일정 수준 : 일반적으로 5~20% 수준의 손익분기점은 10만건 이내, 많아야 100만 이내 / 하지만 1000만건의 10%는 100만건이며 레코드가 근처에 모여있을 가능성이 작다 이럴 경우 만건만 넘어도 Table Full Scan 방식이 더 빠를 수 있다.)
 - **테이블 스캔이 항상 나쁜것은 아니며 인덱스 스캔이 항상 좋은 것만이 아니다.**

### 3.1.5 인덱스만 읽고 처리
- 비효율이 없는 인덱스 스캔에서 조회량이 많아 느릴경우 성능 개선 : 쿼리에 사용된 컬럼을 모두 인덱스에 추가해서 테이블 엑세스를 아예 발생하지 않게 하는 방법도 고래해 볼 수 있음(인덱스만 읽어서 처리하는 쿼리 : Coverde쿼리, 그 쿼리에 사용한 인덱스 : Covered 인덱스)
#### Include 인덱스(오라클엔 없고 SQL Server 2005버전에 추가된 기능)
- 인덱스를 생성할때 아래와 같이 include 옵션을 지정하면 된다.
```sql
create index emp_x01 on emp (deptno) include(sal)
```
- deptno, sal을 모두 인덱스로 만든것을 emp_x02로 가정하여 아래 설명
- emp_x01는 sal 컬럼을 리프 블록에만 저장, emp_x02은 deptno, sal 모두 루트와 블랜치 블록에 저장
- emp_x01은 오직 테이블 랜덤엑세스 획수만 줄이는 용도 이므로 인덱스 스캔량은 emp_x02가 더 적다.

### 3.1.6 인덱스 구조 테이블
- 랜덤 액세스가 아예 발생하지 않도록 테이블을 인덱스 구조로 생성
- 오라클은 IOT(Index-Organized Table), MS-SQL Server은 클러스터형 인덱스라 부른다.
- 테이블 블록에 있어야 할 데이터를 인덱스 리프 블록에 모두 저장
[사진]
```sql
-- 테이블을 인덱스 구조로 만드는 구문
create table index_org_t (a number, b, varchar(10))

organization idex;
```
- 일반 힙 구조 테이블은 순서없이 데이터를 입력하지만 IOT는 정렬을 유지하며 데이터를 입력하므로 클러스터링 팩터가 좋다. 때문에 데이터가 모여있어 BETWEEN이나 부등호 조건으로 넓은 법위를 읽을 때 유리

### 3.1.7 클러스터 테이블
- 클러스터 테이블은 **인덱스 클러스터**와 **해시 클러스터**가 있다.
#### 인덱스 클러스터테이블
- 클러스터 키값이 같은 레코드를 한 블록에 모아서 저장하는 구조
- 일반 인덱스에 생성한 인덱스 레코드는 테이블 레코드와 1:1대응관계
- 클러스터 인덱스는 테이블 레코드와 1:M관계를 갖는다 그러므로 값을 찾을때 랜덤엑세스가 값 하나당 한 번 씩밖에 발생하지 않는다.
- 클러스터에 도달해서는 시퀀셜 방식으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율이 없다
```sql
--먼저 클러스터 생성
create cluster c_dept# ( depton number(2) ) index;

-- 클러스터에 테이블을 담기 전에 클러스터 인덱스를 반드시 정의(검색용도 뿐아니라 데이터가 저장될 위치를 찾을때도 사용하기 때문)
create index c_dept#_idx on cluster c_dept#;

--클러스터 테이블생성
create table dept( deptno number(2), dename varchar(14));
cluster c_dept#(deptno);
```
#### 해시 클러스터터테이블
- 인덱스를 사용하지 않고 해시 알고리즘을 사용해 클러스터를 찾아간다는 점만 다르다.
----
## 3.2 부분범위 처리 활용
- 부분범위 처리 활용을 하면 인덱스로 액세스할 대상 레코드가 아무리 많아도 아주 빠른 응답속도를 낼수 있다
### 3.2.1 부분범위 처리
- 전체 쿼리 결과집합을 쉼 없이 연속적으로 전송하지 않고 사용자로부터 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 것을 **부분범위 처리**라고 한다.(이로 인해 1억 건짜리 테이블인데도 결과를 빨리 출력할 수 있다.)
- 데이터를 전송하는 단위인 Array Size는 클라이언트 프로그램에서 설정한다.
### 정렬 조건이 있을 때 부분범위 처리
- 정렬 사용시 데이터를 다 읽어 Order by에 사용된 컬럼 순으로 정렬을 마치고서야 클라이언트에게 데이터 전송을 시작할 수 있다.(**전체범위처리**)
- 컬림이 선두인 **인덱스**가 있으면, 부분범위 처리가 가능하다(인덱스는 항상 정렬된 상태를 유지하므로)
### Array Size조정을 통한 Fetch Call 최소화
- Array Size를 조정한다고 해서 전송해야 할 총량이 변하지 않지만, Fetch Call 횟수를 그만큼 줄일 수 있다.

### 3.2.3 OLTP 환경에서 부분범위 처리에 의한 성능개선 원리
#### 멈출 수 있어야 의미있는 부분범위 처리
- 클라이언트 프로그램과 DB서버가 직접 접속되어있는 2-Tier환경에서는 앞쪽 일부만 출력하고 멈출 수 있다.
- 클라이언트 프로그램과 DB서버 사이에 WAS, AP 서버등이 존재하는 n-Tier아키텍처에서는 결과를 클라이언트에 '모두' 전송하고 커서를 닫아야 하므로 나눠 전송하기 어렵다. 그래도 n-Tier환경에서도 부분범위 처리는 가능하다(5장 3절에서 설명)
#### 배치 I/O
- 배치 I/O는 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안한 기능으로 테이블 블록에 대한 디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리
- 배치 I/O기능(/*+ batch_table_access_by_rowid(e) */)이 작동하면 소트 연산자를 생략할 수 있는 인덱스가 있더라도 순서를 보장할 수 없으므로 옵티마이저가 sort연산을 사용하게된다.
- 인덱스로 소트 연산을 생략할 수 없거나 sql에 order by가 없으면 랜덤 I/O성능을 향상하는 배치 I/O를 사용한다.(순서 보장이 필요 없기 때문에)
- 배치 I/O를 선택했을 때는 출력된 결과 정렬 순서가 매번 다를 수 있다.
----
## 3.3 인덱스 스캔 효율화


  
