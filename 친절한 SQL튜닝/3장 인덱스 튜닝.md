# 인덱스 튜닝
## 3.1 테이블 액세스 최소화
- 테이블 랜덤 액세스를 최소화하는 구체적인 방법들 소개
### 3.1.1 테이블 랜덤 엑세스
- 인덱스 ROWID는 물리적 주소가 아닌 논리적 주소이며 디스크 상에서 테이블 레코드르 찾아가기 위한 위치 정보를 담는다. ROWID를 이용한 테이블 액세스가 생각만큼 빠르지 않다 (프로그래밍에서의 물리적주소인 포인터와 다름)
- I/O 성능을 높이려면 버퍼캐시를 활용해야한다. ROWID가 가리키는 테이블 블록 버퍼캐시를 먼저 찾고 못찾을 때는 디스크 블록을 읽는다. 모든 데이터가 캐싱 돼있어도 테이블 레코드르 찾기 위해 매번 DBA해싱과 래치 획득 과정을 반복해는 등 **인덱스 ROWID를 이용한 테이블 엑세스는 생각보다 고비용 구조다**

### 3.1.2 인덱스 클러스터링 팩터
- 클러스터링 팩터(CF)는 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다.
- 인덱스는 검색효율이 매우 좋다.
- CF가 좋은 인덱스 사용시 블록 I/O가 적게 발생하는 이유 : 인덱스 ROWID로 테이블 액세스 할때 래치 획득과 해시 체인 스캔 과정을 거쳐 어럽게 찾아간 테이블 블록에대한 포인터를 해제하지 않고 일단 유지한다(버퍼 Pinning), 다음 인덱스 코드를 읽었을때 '직전과 같은 테이블 블록을 가리킨다'
[사진]

 ### 3.1.3 인덱스 손익 분기점
 - Table Full Scan은 1000만 건중 한건이든 10만건조회이든 성능은 일정하다.
 - Table Full Scan : 시퀀스 엑세스, Multiblock I/O
 - 인덱스 ROWID 이용 테이블 액세스 : 랜덤 액세스, Single Block I/O
 - 읽어야 할 데이터가 일정량을 넘는 순간, 테이블 전체를 스캔한 것보다 느려진다.(일정 수준 : 일반적으로 5~20% 수준의 손익분기점은 10만건 이내, 많아야 100만 이내 / 하지만 1000만건의 10%는 100만건이며 레코드가 근처에 모여있을 가능성이 작다 이럴 경우 만건만 넘어도 Table Full Scan 방식이 더 빠를 수 있다.)
 - **테이블 스캔이 항상 나쁜것은 아니며 인덱스 스캔이 항상 좋은 것만이 아니다.**

### 3.1.5 인덱스만 읽고 처리
- 비효율이 없는 인덱스 스캔에서 조회량이 많아 느릴경우 성능 개선 : 쿼리에 사용된 컬럼을 모두 인덱스에 추가해서 테이블 엑세스를 아예 발생하지 않게 하는 방법도 고래해 볼 수 있음(인덱스만 읽어서 처리하는 쿼리 : Coverde쿼리, 그 쿼리에 사용한 인덱스 : Covered 인덱스)
#### Include 인덱스(오라클엔 없고 SQL Server 2005버전에 추가된 기능)
- 인덱스를 생성할때 아래와 같이 include 옵션을 지정하면 된다.
```sql
create index emp_x01 on emp (deptno) include(sal)
```
- deptno, sal을 모두 인덱스로 만든것을 emp_x02로 가정하여 아래 설명
- emp_x01는 sal 컬럼을 리프 블록에만 저장, emp_x02은 deptno, sal 모두 루트와 블랜치 블록에 저장
- emp_x01은 오직 테이블 랜덤엑세스 획수만 줄이는 용도 이므로 인덱스 스캔량은 emp_x02가 더 적다.

### 3.1.6 인덱스 구조 테이블
- 랜덤 액세스가 아예 발생하지 않도록 테이블을 인덱스 구조로 생성
- 오라클은 IOT(Index-Organized Table), MS-SQL Server은 클러스터형 인덱스라 부른다.
- 테이블 블록에 있어야 할 데이터를 인덱스 리프 블록에 모두 저장
[사진]
```sql
-- 테이블을 인덱스 구조로 만드는 구문
create table index_org_t (a number, b, varchar(10))

organization idex;
```
- 일반 힙 구조 테이블은 순서없이 데이터를 입력하지만 IOT는 정렬을 유지하며 데이터를 입력하므로 클러스터링 팩터가 좋다. 때문에 데이터가 모여있어 BETWEEN이나 부등호 조건으로 넓은 법위를 읽을 때 유리

### 3.1.7 클러스터 테이블
- 클러스터 테이블은 **인덱스 클러스터**와 **해시 클러스터**가 있다.
#### 인덱스 클러스터테이블
- 클러스터 키값이 같은 레코드를 한 블록에 모아서 저장하는 구조
- 일반 인덱스에 생성한 인덱스 레코드는 테이블 레코드와 1:1대응관계
- 클러스터 인덱스는 테이블 레코드와 1:M관계를 갖는다 그러므로 값을 찾을때 랜덤엑세스가 값 하나당 한 번 씩밖에 발생하지 않는다.
- 클러스터에 도달해서는 시퀀셜 방식으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율이 없다
```sql
--먼저 클러스터 생성
create cluster c_dept# ( depton number(2) ) index;

-- 클러스터에 테이블을 담기 전에 클러스터 인덱스를 반드시 정의(검색용도 뿐아니라 데이터가 저장될 위치를 찾을때도 사용하기 때문)
create index c_dept#_idx on cluster c_dept#;

--클러스터 테이블생성
create table dept( deptno number(2), dename varchar(14));
cluster c_dept#(deptno);
```
#### 해시 클러스터터테이블
- 인덱스를 사용하지 않고 해시 알고리즘을 사용해 클러스터를 찾아간다는 점만 다르다.
----
## 3.2 부분범위 처리 활용
- 부분범위 처리 활용을 하면 인덱스로 액세스할 대상 레코드가 아무리 많아도 아주 빠른 응답속도를 낼수 있다
### 3.2.1 부분범위 처리
- 전체 쿼리 결과집합을 쉼 없이 연속적으로 전송하지 않고 사용자로부터 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 것을 **부분범위 처리**라고 한다.(이로 인해 1억 건짜리 테이블인데도 결과를 빨리 출력할 수 있다.)
- 데이터를 전송하는 단위인 Array Size는 클라이언트 프로그램에서 설정한다.
#### 정렬 조건이 있을 때 부분범위 처리
- 정렬 사용시 데이터를 다 읽어 Order by에 사용된 컬럼 순으로 정렬을 마치고서야 클라이언트에게 데이터 전송을 시작할 수 있다.(**전체범위처리**)
- 컬림이 선두인 **인덱스**가 있으면, 부분범위 처리가 가능하다(인덱스는 항상 정렬된 상태를 유지하므로)
#### Array Size조정을 통한 Fetch Call 최소화
- Array Size를 조정한다고 해서 전송해야 할 총량이 변하지 않지만, Fetch Call 횟수를 그만큼 줄일 수 있다.

### 3.2.3 OLTP 환경에서 부분범위 처리에 의한 성능개선 원리
#### 멈출 수 있어야 의미있는 부분범위 처리
- 클라이언트 프로그램과 DB서버가 직접 접속되어있는 2-Tier환경에서는 앞쪽 일부만 출력하고 멈출 수 있다.
- 클라이언트 프로그램과 DB서버 사이에 WAS, AP 서버등이 존재하는 n-Tier아키텍처에서는 결과를 클라이언트에 '모두' 전송하고 커서를 닫아야 하므로 나눠 전송하기 어렵다. 그래도 n-Tier환경에서도 부분범위 처리는 가능하다(5장 3절에서 설명)
#### 배치 I/O
- 배치 I/O는 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안한 기능으로 테이블 블록에 대한 디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리
- 배치 I/O기능(/*+ batch_table_access_by_rowid(e) */)이 작동하면 소트 연산자를 생략할 수 있는 인덱스가 있더라도 순서를 보장할 수 없으므로 옵티마이저가 sort연산을 사용하게된다.
- 인덱스로 소트 연산을 생략할 수 없거나 sql에 order by가 없으면 랜덤 I/O성능을 향상하는 배치 I/O를 사용한다.(순서 보장이 필요 없기 때문에)
- 배치 I/O를 선택했을 때는 출력된 결과 정렬 순서가 매번 다를 수 있다.
----
## 3.3 인덱스 스캔 효율화
### 3.3.2 인덱스 스캔 효율성
- 인덱스 **선행 컬럼**이 조건절에 없거나 '=' 조건이 아니면 인덱스 스캔과정에 비효율 발생
### 인덱스 스캔 효율성 측정
- SQL 트레이스를 통해 효율을 판단할 수 있다
[184 사진]
- 얻은 레코드가 열 개 인데, 그 과정에서 7,463개 블록(cr=7463)을 읽었다
- 한 블록당 평균 500개 레고드가 담긴다 가정하면 3,731,500(7463*500)개 레코드를 읽은 셈

### 3.3.3 액세스 조건과 팰터 조건
- 인덱스 스캔하는 단계에 처리하는 조건절은 **액세스 조건**과 **필터 조건**으로 나뉜다.
- 인덱스 액세스 조건 : 인덱스 스캔 범위를 결정하는 조건절(인덱스 수직적 탐색을 통해 스캔 시작점을 결정하는 데 영향을 미치며 인덱스 리프 블록을 스캩하다가 어디서 멈출지 결정하는 조건절)
- 인덱스 필터 조건 : 테이블로 액세스할지를 결정하는 조건절
- 인덱스를 이용하든, 테이블을 full scan하든 테이블 액세스 단계에서 처리되는 조건절은 모두 필터조건이다. **테이블 필터 조건**은 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지 결정
[185 사진]

### 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성
```
<조건절 1>
where c1 = 1
and   c2 = 'A'
and   c3 = '나'
and   c4 = 'a'

<조건절 2>
where c1 = 1
and   c2 = 'A'
and   c3 = '나'
and   c4 >= 'a'

<조건절 3>
where c1 = 1
and   c2 = 'A'
and   c3 between '가' and '다'
and   c4 = 'a'

<조건절 4>
where c1 = 1
and   c2 <= 'B'
and   c3 = '나'
and   c4  between 'a' and 'b'

<조건절 5>
where between 1 and 3
and   c2 = 'A'
and   c3 = '나'
and   c4 = 'a'
```
- 첫 번째 나타나는 범위 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여 있지만(엑세스 조건)
- 그 이하 조건까지 만족한느 레코드는 비교 연산자 종류와 상관없이 흩어진다(필터조건) 
[189 사진]

## 3.3.5 인덱스 선행 컬림이 등치(=)조건이 아닐때 생기는 비효율
- 인덱스 스캔 효율성은 인덱스 컬럼을 조건절에 모두 등치(=) 조건으로 사용할 때가 가장 좋다.
```sql
  --예시
 where 아파트시세코드 = 'a' 
 and 평형 = '59' 
 and 평형타입 'A'
 and 인터넷 매물 between '1' and '3'
```
- 조건절에 없거나 등치 조건이 아니더라도 그것이 뒷쪽 컬럼일때는 비효율이 없다, 선행 컬럼이 모두 '=' 조건일때 필요한 범위만 스캔하고 멈출 수 있는것은 조건을 만족하는 레코드가 모두 모여있기 때문  
  (인덱스 순서 : 아파트시세코드, 평형, 평형타입, 인터넷 매물)
- 선두 컬럼이 between 연산자를 사용하면 스캔 범위가 넓어져서 비효율이 생긴다  
  (인덱스 순서 : 인터넷 매물, 아파트시세코드, 평형, 평형타입)

## 3.3.6 BETWEEN을 IN-List로 전환
- betwwn 조건을 In-list로 바꿔주면 Union all 형태이며 컬럼이 '=' 조건으로 변경되어 비효율이 사라진다
- IN-list항목 개수가 늘어나면 곤란하므로 이때는 조인문이나 서브쿼리로 구현하여 '='조건으로 조인하도록 변경해준다.

###  IN-List로 전환시 주의사항
- in-list개수가 많으면 수직적 탐색이 많이 발생하여 비효율이된다.
- 인덱스 스캔과정에 선택되는 레코드들이 서로 멀리 떨어져 있을때만 유용하다

## 3.3.7 index Skip Scan활용
- BETWEEN을 IN-List로 변환하는 등 조건절을 바꾸지 않고도 같은 효과를 볼 수 있다.
- 데이터들이 서로 멀리 떨어져 있을때 효과가 좋다.

## 3.3.8 IN 조건은 '='인가
- 결론은 IN은 '='가 아니다. 따라서 어떻게 구성하느냐에 따라 성능도 달라진다.
- 고객별가입상품 테이블에서 고객번호의 평균 카디널리티가 3이라고 가정하자
- 인덱스를 (상품ID, 고객번호) 순으로 생성하면 연속되지 않은 세개 리프 블록이 저장된다.
  [204 그림]
- 인덱스를 (고객번호, 상품ID) 순으로 생성하면 인덱스를 수직적으로 세번 탐색하는 과정에 아홉 개 블록을 읽는다.
  [205 그림]

  
