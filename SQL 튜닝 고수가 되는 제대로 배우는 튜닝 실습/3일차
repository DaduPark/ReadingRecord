읽는위치(메모리, 디스크 ?)
sga
P48 
1사진
하단 세개파일들은 메모리에 올라와야되느것

사용자가 접근 방법 : CLI(SQL PLUS), GUI(SQL DEVELOPER, ..) 
위에꺼로 접속을 신청함(기본포트값 1521(리스터))
서버프로세스가 사용자의 접속을 받아 PGA란 공간을 만듦
SGA(요리공간)
하단 백그라운드 프로세스가 있음

0. 쿼리문이 오면

(파싱)
1. 파싱을 통해 문법검사를 함.
2. 개체 검사를 함
3. 권한검사

4.share pool에 확인해보고 없으면 가져온다(블럭단위로)
5.pga로 보내고 사용자한테 보냄

이러한과정을 빠르게 처리하는 것이 실행계획을 처리하는것=> 옵티마이져가 처리해줌

문리적 읽기 : database에서 sga로 가져오는것(새로운 문법을 읽는것)
논리적 읽기 : sga에서 pga로 가져오는것

pga위치
sort 에어리어 : order by는 여기서해줌
해쉬 에어리어 : 헤시 조인에서 이용하는 공간

힌트 : 옵티마이져가 짜놓은 실행계획을 사용자가 변경하는것



-------------------------
컴파일언어는 한자한자 인코딩하므로
- select * From t1 과 Select * from t1을 다르게 처리한다.
- share pool에서 다르게 처리하여 새로 가져온다
- 대소문자의 룰을 가지고 맞춰나가야한다

----------------
쿼리 읽는 순서
5select
1from 
2where
3group by
4having
6order vy 
=> where 과 having으로 조건을걸때 결과 같이 같더라도 where에 거는것이 성능이 좋다(처음에 걸러내는것이 양을 줄일수있다)
=> 테이블 별칭은 어디에서든 다 적용이 되고 컬럼 별칭은 나머지에서 해석이 안되지만 order by에서 읽힌다다 







------------------------

create table t1
( c1 int, 
  c2 int, 
  c3 int);--인덱스가 걸리지않은 heap의 상태

drop table t1;

create table t1
( c1 int primary key, 
  c2 int unique, 
  c3 int);
-- c1, c2는 인덱스를 타고 c3는 heap으로 검색됨

set autotrace on exp;

select * from t1;
--실행계획순서(F5)
--좌측을 기준으로 들어가있는것이 제일먼저 
-- 같은 레이어면 위쪽이 먼저 실행된것

--------------------------------------------------------------------------
--| Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------
--|   0 | SELECT STATEMENT  |      |     1 |    39 |     2   (0)| 00:00:01 |
--|   1 |  TABLE ACCESS FULL| T1   |     1 |    39 |     2   (0)| 00:00:01 |
--------------------------------------------------------------------------
-- 조건이 없어서 힙데이터로 탐색

select * from t1 where c1=10;
--------------------------------------------------------------------------------------------
| Id  | Operation                   | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |              |     1 |    39 |     1   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| T1           |     1 |    39 |     1   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN         | SYS_C0011127 |     1 |       |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------
-- c1인덱스를 내려갈 계획을짬
select * from t1 where c2=10;

--------------------------------------------------------------------------------------------
| Id  | Operation                   | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT        --최종적으로 pga에 넘겨줌    |              |     1 |    39 |     1   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID -- rowid로 힙데이터의 데이터를 찾음| T1           |     1 |    39 |     1   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN       --인덱스를 탐  | SYS_C0011128 |     1 |       |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------
-- c2인덱스를 내려갈 계획을짬


select * from t1 where c3=10;

--------------------------------------------------------------------------
| Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |      |     1 |    39 |     2   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| T1   |     1 |    39 |     2   (0)| 00:00:01 |
--------------------------------------------------------------------------
-- 힙데이터를 바라봄


--결과
--제약조건은 인덱스가 걸리는 제약조건
--
------------------------------------------
select * from t1 where c1 < 10;
select * from t1 where c2 < 10;
select * from t1 where c3 < 10;

--------------------------------------------------------------------------
| Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |      |     1 |    39 |     2   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| T1   |     1 |    39 |     2   (0)| 00:00:01 |
--------------------------------------------------------------------------
 모두 테이블 풀스캔으로 함 -> 양이 많아질것을 판단하여 full스캔으로 타게 함
 (데이터가 없는 상태라 모두 full스캔으로 탐)
 -------------------------------------------------------------------------------
 create table emp01
 as
 select * from emp;
 
 
 select * from emp01;
 -> 데이터만 복사하고 제약조건, 인덱스는 복사안됨
 
 select * from emp where empno = 7788;
 --------------------------------------------------------------------------------------
| Id  | Operation                   | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |        |     1 |    38 |     1   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP    |     1 |    38 |     1   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN         | PK_EMP |     1 |       |     0   (0)| 00:00:01 |
--------------------------------------------------------------------------------------
 select * from emp01 where empno = 7788;
 ---------------------------------------------------------------------------
| Id  | Operation         | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |       |     1 |    87 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMP01 |     1 |    87 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------








show parameter block_size;

NAME          TYPE    VALUE 
------------- ------- ----- 
db_block_size integer 8192  

- 1페이지당 8K로 잡힘

select value from v$parameter where name = 'db_block_size';

value
-----
8192










where 뒤, 조건의 유형 5

- point 조건 : =
- 범위(Range) 조건 : >,<=
- 열거 조건 : in (a,b,c,,,)
- 패턴 조건 : like _ , %
- 상태 조건 : is null, is not null





select * from emp where empno = 7788;

--------------------------------------------------------------------------------------
| Id  | Operation                   | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |        |     1 |    38 |     1   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP    |     1 |    38 |     1   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN         | PK_EMP |     1 |       |     0   (0)| 00:00:01 |
--------------------------------------------------------------------------------------

- INDEX UNIQUE SCAN 

select * from emp where empno between 7788 and 7600;

---------------------------------------------------------------------------------------
| Id  | Operation                    | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |        |     1 |    38 |     0   (0)|          |
|*  1 |  FILTER                      |        |       |       |            |          |
|   2 |   TABLE ACCESS BY INDEX ROWID| EMP    |     1 |    38 |     2   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN          | PK_EMP |     1 |       |     1   (0)| 00:00:01 |
---------------------------------------------------------------------------------------

- INDEX RANGE SCAN

------------------------------
create index idx01_emp01 on emp01(empno);

select * from emp01 where empno = 7788;
-------------------------------------------------------------------------------------------
| Id  | Operation                   | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |             |     1 |    87 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP01       |     1 |    87 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | IDX01_EMP01 |     1 |       |     1   (0)| 00:00:01 |

select * from emp01 where empno between 7788 and 7600;
--------------------------------------------------------------------------------------------
| Id  | Operation                    | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |             |     1 |    87 |     0   (0)|          |
|*  1 |  FILTER                      |             |       |       |            |          |
|   2 |   TABLE ACCESS BY INDEX ROWID| EMP01       |     1 |    87 |     0   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN          | IDX01_EMP01 |     1 |       |     0   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------

둘다  INDEX RANGE SCAN   로 나온다.
-emp01의 인덱스는 pk인덱스가 아닌 idx01_emp01에 의한 인덱스
- 4,5 사진 비교
- pk는 고유 idx01_emp01는 고유하지 않음 으로 뜸
- pk 컬럼은 unique하므로 한 행씩만 찾으면되지만 두번째 idx01_emp01에서 만든 인덱스는 유니크인덱스가 아니므로 다른곳에도 있을 수도 있으므로 range scan을 하는것임
- 같게 하기위해서는 "create **unique** index idx01_emp01 on emp01(empno);"로 설정해야됨

- 앞쪽(ASC)에서 찾을확률이 높은데이터가 있고 뒷쪽(DESC)에서 찾을 확률이 높은 데이터가 있으므로 asc, desc로 선택하여 인덱스를 만들 수 있다 / 오른차순정렬(INDEX_DESC)을 사용하여 거꾸로 읽어나갈수도있다





select  /*+ full(emp) */ *
from emp where empno = 7788;

---------------------------------------------------------------------------
| Id  | Operation         | Name  | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |       |     1 |    87 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMP01 |     1 |    87 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------

-힌트절로 변경

select  /*+ full(emp) */ *
from emp e where empno = 7788;

--------------------------------------------------------------------------------------
| Id  | Operation                   | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |        |     1 |    38 |     1   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP    |     1 |    38 |     1   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN         | PK_EMP |     1 |       |     0   (0)| 00:00:01 |
--------------------------------------------------------------------------------------

- 테이블 별칭을 사용하면 힌트 적용도 안된다 (힌트가 적용되었는지 제대로 확인해보아야한다)










create index idx02_emp01 on emp01(ename);

select /*+ index(emp01 idx01_emp01 ) */ * from emp01;
-조건이 없는데 억지스레 힌트를 태워도 타지않는다(full scan)

select * from emp01 where ename='SMITH';
select /*+ index(emp01 idx01_emp01 ) */ * from emp01 where ename='SMITH';
-조건이 없는데 억지스레 힌트를 태워도 타지않는다(idx02_emp01인덱스를 탐)


-결합인덱스
create index idx03_emp01 on emp01(empno, ename);

select * from emp01 where empno=7788;

-------------------------------------------------------------------------------------------
| Id  | Operation                   | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |             |     1 |    87 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP01       |     1 |    87 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | IDX01_EMP01 |     1 |       |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------
--empno의 인덱스만 가지고있는 IDX01_EMP01가 더 효과적이다

select /*+ index(emp01 idx03_emp01 ) */  * from emp01 where empno=7788;
-------------------------------------------------------------------------------------------
| Id  | Operation                   | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |             |     1 |    87 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP01       |     1 |    87 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | IDX03_EMP01 |     1 |       |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------


select ename from emp01 where empno=7788;
--------------------------------------------------------------------------------
| Id  | Operation        | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------
|   0 | SELECT STATEMENT |             |     1 |    20 |     1   (0)| 00:00:01 |
|*  1 |  INDEX RANGE SCAN| IDX03_EMP01 |     1 |    20 |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------
- IDX03_EMP01에 empno, ename를 모두 가지고 있으므로 heap데이터까지 안가도된다.
- 하지만 인덱스에 컬럼이 많이 걸리게되면 인덱스페이지가 많아지고 조작에도 성능이 떨어지므로 성능이 떨어질수있다

select empno from emp01 where ename='SCOTT';
--------------------------------------------------------------------------------
| Id  | Operation        | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------
|   0 | SELECT STATEMENT |             |     1 |    20 |     1   (0)| 00:00:01 |
|*  1 |  INDEX FULL SCAN | IDX03_EMP01 |     1 |    20 |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------

- 인덱스의 선두컬럼을 기준으로 찾는것이 아니므로 INDEX FULL SCAN으로 탄다 (테이블 풀 스캔보다는 성능이 좋음)
